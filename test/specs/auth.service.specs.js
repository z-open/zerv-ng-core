
describe('Unit testing for auth,', () => {
    let $auth;
    let socket;
    let sessionUser;
    let $timeout;
    let $rootScope;
    let authProvider;
    const refreshedToken = 'aTokenDecodedByTheMock';

    beforeEach(module('zerv.core', function($authProvider) {
        authProvider = $authProvider;
        $authProvider.setDebug(true);
        $authProvider.setLogoutUrl('http://mydomain/logoutPage');
    }));

    beforeEach(() => {
        jasmine.clock().install();

        const baseTime = new Date(Date.UTC(2020, 9, 30, 14, 52, 28));
        jasmine.clock().mockDate(baseTime);


        mockSocket();
        mockIo();

        inject(function($injector, _$rootScope_, _$q_, _$timeout_) {
            $auth = $injector.get('$auth');
            sessionUser = $injector.get('sessionUser');
            $rootScope = _$rootScope_;
            $q = _$q_;
            $timeout = _$timeout_;
        });

        spyOn($auth, 'redirect');
        spyOn($auth, 'decodeToken').and.callThrough();

        // mock the payload of the token as it would have a 60-day validity
        const sessionDurationInMins = 60 * 24 * 10;
        const expiresOn = new Date(baseTime.getTime() + (sessionDurationInMins * 60 * 1000));

        $auth.decodeToken.and.returnValue({
            display: 'Juan Marco',
            iat: Math.round(baseTime.getTime() / 1000),
            exp: Math.round(expiresOn.getTime() / 1000),
        });

        localStorage.token = 'vvv';
    });


    afterEach(() => {
        delete window.localStorage.token;
        delete window.localStorage.origin;
        jasmine.clock().uninstall();
    });

    it('decodeToken should retrieve the token payload', () => {
        $auth.decodeToken.and.callThrough();
        // example of genuine token generated by the backend
        const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6Ijg5ZTczM2U4LWJlMjUtNDEyYy04NmM1LTgzNjc4OTAwMmMwZiIsImRpc3BsYXkiOiJBZGFtIEJvb3QiLCJmaXJzdE5hbWUiOiJBZGFtIiwibGFzdE5hbWUiOiJCb290Iiwicm9sZSI6ImFkbWluIiwib3JnSWQiOiIwZTQyZGY2YS1kYTUzLTQ1M2ItYWQxZS1jZjQ3Yjg2ODVhMjAiLCJwcm9maWxlIjp7ImltYWdlIjoidG8gaGF2ZSB0aGUgcHJvcGVyIHZhbHVlLCBtb2RpZnkgY2xhaW0gaW4gYXBpLXNlcnZlciJ9LCJpYXQiOjE2MDQwODYyNTIsImp0aSI6MSwiZHVyIjozNjAwLCJleHAiOjE2MDQwODY4NTJ9.6qcLsGbz15wio9aXW2v0Hj3SF61p6OHJaQWWRwPkWUA';
        const payload = $auth.decodeToken(token);

        // mandatory fields must exist for the lib to work:
        expect(payload.id).toEqual('89e733e8-be25-412c-86c5-836789002c0f');
        expect(payload.display).toEqual('Adam Boot');
        expect(payload.iat).toEqual(1604086252);
        expect(payload.jti).toEqual(1);
        expect(payload.dur).toEqual(3600);
        expect(payload.exp).toEqual(1604086852);
    });

    describe('Connect', () => {
        it('should connect and store the new token and user', (done) => {
            $auth.connect().finally(() => {
                expect($auth.decodeToken).toHaveBeenCalled();
                expect(socket.callback).toHaveBeenCalledWith('OK');
                expect(socket.callback).toHaveBeenCalledTimes(1);
                expect(localStorage.token).toEqual(refreshedToken);
                expect(localStorage.origin).toEqual(refreshedToken);
                expect(sessionUser.display).toEqual('Juan Marco');
                expect(socket.emit.calls.allArgs()).toEqual([
                    ['connect'],
                    ['authenticate', {token: 'vvv', origin: null}],
                    ['authenticated', 'aTokenDecodedByTheMock'],
                ]);

                done();
            });
            $rootScope.$apply();
            // fake server responding to the socket
            socket.emit('connect');
            socket.emit('authenticated', refreshedToken);
            $timeout.flush();
        });

        it('should connect using websocket as default transport', () => {
            $auth.connect();
            expect(window.io.connect).toHaveBeenCalledWith({forceNew: true, transports: ['websocket']});
        });

        it('should connect using long polling as a preference to initiate socket', () => {
            authProvider.enableLongPolling(true);
            $auth.connect();
            expect(window.io.connect).toHaveBeenCalledWith({forceNew: true});
        });

        it('should not receive the connect at all and timeout', (done) => {
            $auth.connect().catch((err) => {
                expect(err).toEqual('USER_NOT_CONNECTED');
                done();
            });
            $rootScope.$apply();
            $timeout.flush();
        });

        it('should connect but timeout because not receiving the authenticated acknowledgement', (done) => {
            $auth.connect().catch((err) => {
                expect(err).toEqual('USER_NOT_CONNECTED');
                done();
            });
            $rootScope.$apply();
            // fake server responding to the socket
            socket.emit('connect');
            // socket.emit("authenticated", refreshedToken);
            $timeout.flush();
        });

        it('should already be connected if it connected before', (done) => {
            $auth.connect().finally(() => {
                $auth.connect().finally(() => {
                    expect(socket.callback).toHaveBeenCalledTimes(1);
                    done();
                });
            });
            $rootScope.$apply();
            // fake server responding to the socket
            socket.emit('connect');
            socket.emit('authenticated', refreshedToken);
            $timeout.flush();
        });
    });

    describe('logout', () => {
        it('should not call logout without connection', () => {
            $auth.logout();
            expect(socket.emit).not.toHaveBeenCalled();
        });

        it('should emit a log out to the server and clear the localstorage state and redirect to the logout url', (done) => {
            $auth.connect().finally(() => {
                $auth.logout();
                expect( localStorage.token ).not.toBeDefined();
                expect( localStorage.origin ).not.toBeDefined();
                expect(socket.emit).toHaveBeenCalledTimes(4);
                expect(socket.emit.calls.allArgs()).toEqual([
                    ['connect'],
                    ['authenticate', {token: 'vvv', origin: null}],
                    ['authenticated', 'aTokenDecodedByTheMock'],
                    // the logout provide the token to the backend
                    ['logout', 'aTokenDecodedByTheMock'],
                ]);
                jasmine.clock().tick(5000);
                expect($auth.redirect).toHaveBeenCalledTimes(1);
                expect($auth.redirect).toHaveBeenCalledWith('http://mydomain/logoutPage');
                done();
            });

            $rootScope.$apply();
            // fake server responding to the socket
            socket.emit('connect');
            socket.emit('authenticated', refreshedToken);
            $timeout.flush();
        });

        it('should receive a logout command from the server', (done) => {
            $auth.connect().finally(() => {
                // fake server responding..
                socket.emit('logged_out');
                expect( localStorage.token ).not.toBeDefined();
                expect( localStorage.origin ).not.toBeDefined();
                expect(socket.emit).toHaveBeenCalledTimes(4);
                expect(socket.emit.calls.allArgs()).toEqual([
                    ['connect'],
                    ['authenticate', {token: 'vvv', origin: null}],
                    ['authenticated', 'aTokenDecodedByTheMock'],
                    // Received from the backend
                    ['logged_out'],
                ]);
                jasmine.clock().tick(5000);
                expect($auth.redirect).toHaveBeenCalledTimes(1);
                expect($auth.redirect).toHaveBeenCalledWith('http://mydomain/logoutPage');
                done();
            });

            $rootScope.$apply();
            // fake server responding to the socket
            socket.emit('connect');
            socket.emit('authenticated', refreshedToken);
            $timeout.flush();
        });

        it('should log out/redirect once when the logout is both iniated from the client and the server', (done) => {
            $auth.connect().finally(() => {
                $auth.logout();
                // //fake server responding..
                socket.emit('logged_out');
                expect( localStorage.token ).not.toBeDefined();
                expect( localStorage.origin ).not.toBeDefined();
                expect(socket.emit.calls.allArgs()).toEqual([
                    ['connect'],
                    ['authenticate', {token: 'vvv', origin: null}],
                    ['authenticated', 'aTokenDecodedByTheMock'],
                    // the logout provide the token to the backend
                    ['logout', 'aTokenDecodedByTheMock'],
                    ['logged_out'],
                ]);
                jasmine.clock().tick(5000);
                expect($auth.redirect).toHaveBeenCalledTimes(1);
                expect($auth.redirect).toHaveBeenCalledWith('http://mydomain/logoutPage');
                done();
            });

            $rootScope.$apply();
            // fake server responding to the socket
            socket.emit('connect');
            socket.emit('authenticated', refreshedToken);
            $timeout.flush();
        });
    });

    describe('setSocketConnectionOptions', () => {
        it('should set the socket options', (done) => {
            authProvider.setSocketConnectionOptions({someSocketIoOption: 'value'});
            $auth.connect();
            expect( window.io.connect).toHaveBeenCalledWith({someSocketIoOption: 'value', forceNew: true, transports: ['websocket']});
            done();
        });

        it('should be set to default value (when not called)', (done) => {
            $auth.connect();
            expect( window.io.connect).toHaveBeenCalledWith({forceNew: true, transports: ['websocket']});
            done();
        });
    });

    describe('User active session timeout monitor', () => {
        beforeEach(() => {
            spyOn($auth, 'logout');
        });

        it('should logout when the session expires', () => {
            // let's disengage the inactivity timeout
            $auth.setInactiveSessionTimeoutInMins(0);
            connectSession();
            jasmine.clock().tick( 9 * 24 * 60 * 60 *1000);
            expect($auth.logout).not.toHaveBeenCalled();
            // at the 10th day the session will expire
            jasmine.clock().tick( 1 * 24 * 60 * 60 * 1000);
            expect($auth.logout).toHaveBeenCalledWith('session_expired');
        });
    });

    describe('User inactivity monitor', () => {
        beforeEach(() => {
            spyOn($auth, 'logout');
        });

        describe('setInactiveSessionTimeoutInMins', () => {
            it('should set to logout after time of inactivity', () => {
                $auth.setInactiveSessionTimeoutInMins(1);
                connectSession();
                expect($auth.getRemainingInactiveTime()).toBe(60000);
                expect($auth.logout).not.toHaveBeenCalled();
                jasmine.clock().tick( 30*1000);
                expect($auth.getRemainingInactiveTime()).toBe(30000);
                expect($auth.logout).not.toHaveBeenCalled();
                jasmine.clock().tick( 30*1000);
                expect($auth.logout).toHaveBeenCalledWith('inactive_session_timeout');
            });

            it('should set to logout to 7 days if setting is too high', () => {
                $auth.setInactiveSessionTimeoutInMins(10000000);
                expect($auth.getInactiveSessionTimeoutInMins()).toEqual(10080);
                connectSession();
                jasmine.clock().tick( 6 * 24 * 60 * 60*1000);
                expect($auth.logout).not.toHaveBeenCalled();
                jasmine.clock().tick( 24 * 60 * 60*1000);
                expect($auth.logout).toHaveBeenCalledWith('inactive_session_timeout');
            });

            it('should set to logout to 7 days if setting is negative', () => {
                $auth.setInactiveSessionTimeoutInMins(-100);
                expect($auth.getInactiveSessionTimeoutInMins()).toEqual(10080);
            });

            it('should never logout when settings is set to 0', () => {
                $auth.setInactiveSessionTimeoutInMins(0);
                connectSession();
                jasmine.clock().tick( 7 * 24 * 60 * 60*1000);
                expect($auth.logout).not.toHaveBeenCalled();
            });

            it('should never logout when settings is set between 0 and 1', () => {
                $auth.setInactiveSessionTimeoutInMins(0.5);
                connectSession();
                jasmine.clock().tick( 9 * 24 * 60 * 60 * 1000);
                expect($auth.logout).not.toHaveBeenCalled();
                // expected active session timeout to kick in after 10 days
                jasmine.clock().tick( 1 * 24 * 60 * 60 * 1000);
                expect($auth.logout).toHaveBeenCalled();
            });

            it('should reset to logout after a different time of inactivity', (done) => {
                $auth.setInactiveSessionTimeoutInMins(1);
                connectSession();
                expect($auth.logout).not.toHaveBeenCalled();
                jasmine.clock().tick( 30*1000);
                $auth.setInactiveSessionTimeoutInMins(1.25);
                expect($auth.logout).not.toHaveBeenCalled();
                jasmine.clock().tick( 30*1000);
                expect($auth.logout).not.toHaveBeenCalled();
                jasmine.clock().tick( 45*1000);
                expect($auth.logout).toHaveBeenCalledWith('inactive_session_timeout');
                done();
            });
        });

        describe('reset', () => {
            beforeEach(() => {
                $auth.setInactiveSessionTimeoutInMins(1);
                connectSession();
                jasmine.clock().tick(30*1000);
            });

            it('should occur on mousemove', () => {
                document.dispatchEvent(new Event('mousemove'));
                expect($auth.getRemainingInactiveTime()).toBe(60000);
                jasmine.clock().tick( 30*1000);
                expect($auth.logout).not.toHaveBeenCalled();
                jasmine.clock().tick( 30*1000);
                expect($auth.logout).toHaveBeenCalledWith('inactive_session_timeout');
            });

            it('should occur on mousedown', () => {
                document.dispatchEvent(new Event('mousedown'));
                expect($auth.getRemainingInactiveTime()).toBe(60000);
                jasmine.clock().tick( 60*1000);
                expect($auth.logout).toHaveBeenCalledWith('inactive_session_timeout');
            });

            it('should occur on keypress', () => {
                document.dispatchEvent(new Event('keypress'));
                expect($auth.getRemainingInactiveTime()).toBe(60000);
                jasmine.clock().tick( 60*1000);
                expect($auth.logout).toHaveBeenCalledWith('inactive_session_timeout');
            });

            it('should occur on touchmove', () => {
                document.dispatchEvent(new Event('touchmove'));
                expect($auth.getRemainingInactiveTime()).toBe(60000);
                jasmine.clock().tick( 60*1000);
                expect($auth.logout).toHaveBeenCalledWith('inactive_session_timeout');
            });

            it('should occur maximum every second', () => {
                document.dispatchEvent(new Event('mousemove'));
                jasmine.clock().tick(500);
                document.dispatchEvent(new Event('mousemove'));
                // the timeout was not resetted despite the mousemove.
                expect($auth.getRemainingInactiveTime()).toBe(59500);
                jasmine.clock().tick(300);
                document.dispatchEvent(new Event('mousemove'));
                // the timeout was still not resetted despite the mousemove.
                expect($auth.getRemainingInactiveTime()).toBe(59200);
                jasmine.clock().tick(200);
                // 1s passed by since it was resetted, this new event will reset the timeout
                document.dispatchEvent(new Event('mousemove'));
                expect($auth.getRemainingInactiveTime()).toBe(60000);
                jasmine.clock().tick(60*1000);
                expect($auth.logout).toHaveBeenCalledWith('inactive_session_timeout');
            });
        });
    });
    // //////////// HELPERS ///////////////////

    function connectSession() {
        $auth.connect();
        $rootScope.$apply();
        socket.emit('connect');
        socket.emit('authenticated', refreshedToken);
        $timeout.flush();
    }

    function mockIo() {
        window.io = {
            connect: jasmine.createSpy('ioConnect').and.callFake(() => socket),
        };
    }

    function mockSocket() {
        const socketListeners = {};
        socket = {
            emit: jasmine.createSpy('socketEmit'),
            on: function(event, fn) {
                // console.log("on: " + event);
                socketListeners[event] = fn;
                return socket;
            },
            connect: jasmine.createSpy('socketConnect'),
            callback: jasmine.createSpy('socketCallback'),
        };

        socket.emit.and.callFake(
            function(event, data, callback) {
                console.log('emiting ' + event);
                if (socketListeners[event]) {
                    var r = socketListeners[event](data, socket.callback);
                    if (callback) {
                        callback(r);
                    }
                }
            }
        );
    }
});
